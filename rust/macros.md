# Macros

Macros allow metaprogramming: they are code that produce other code at compile time, and they are mostly used to avoid excessive duplication and boilerplate.

Unlike funcions, macros in Rust take a variable number of arguments, ignore the types of values, and must be defined or brought into scope before they are called, exactly because they are expanded during compilation.

## Declarative macros

*Declarative macros* take some Rust code as input value, match it against some patterns, and replace the input code with the code associated to the matching branch:

```rust
#[macro_export]
macro_rules! vec {
  ($($x:expr),*) => {
    {
      let mut temp_vec = Vec::new();
      $(
        temp_vec.push($x);
      )*
      temp_vec
    }
  };
}
```

- here the `#[macro_export]` annotation is used to make this macro available wherever the crate where this macro is defined is brought into scope
- `vec` is the name of the macro, that will be used in the code as `vec!`
- in this case there's only one valid pattern that can be matched, which is `($($x:expr),*)`, and any use of this macro with code that doesn't match the pattern will result in an error
- in a macro pattern, `$()` is used to capture values matching a certain pattern and store them in a variable
- in this case, with `$x:expr` all Rust code matching the pattern `expr`, meaning Rust code that is an expression, is stored in the variable `$x`
- next to the `$()` capture block, the pattern `,*` has the same meaning as in regular expressions, i.e. any code starting with a comma that might be present after the captured code
- for example, if we used this macro with `vec![1, 2, 3]`, the macro pattern will match three times, with `1`, `2`, and `3`, because they are all expressions optionally followed by a comma and something else
- like in `match` expressions, we need to use curly braces after an arrow `=>`, to define the body of the matching branch here as well
- inside the matching branch we find the Rust code that needs to be replaced to the given code
- in this case the replacing code starts by opening a new code block with `{...};`, and then initializes a vector `temp_vec`
- next we find another instance of `$()`, which is again macro syntax that here is used to expand some code using the `$x` value captured in the macro pattern
- in particular, `$()*` means that the expansion of `$()` must be repeated for every value that has been captured
- inside the expansion we find `temp_vec.push($x);`, which just pushes the captured value `$x` to the vector previously defined
- finally, the `temp_vec` is returned out of the code block

the code generated by this macro when it's called with `vec![1, 2, 3]` will then be:

```rust
let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
```

## Procedural macros

Like declarative macros, *procedural macros* take some code as an input and produce some code as an output, but unlike them there is no pattern matching, so they can be used with any code, and the original code is not replaced, but new code is just added to it.

The definitions of procedural macros must be placed in their own crate, with a special crate type:

```rust
// src/lib.rs
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
  // ...
}
```

here the `proc_macro` crate defines the `TokenStream` type, representing a sequence of tokens, and the function `some_name` is expected to take some tokens as input and produce some other tokens as output.

### Derive macros

*Derive macros* provide a quick way to define the implementation of a trait on a struct, without having to write the boilerplate code, and are used like this:

```rust
// src/main.rs
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
  Pancakes::hello_macro();
}
```

the `HelloMacro` trait has to be defined in its own file:

```rust
// src/lib.rs
pub trait HelloMacro {
  fn hello_macro();
}
```

the procedural macro instead has to be defined in its own crate:

```rust
// hello_macro_derive/Cargo.toml
[lib]
proc-macro = true

[dependencies]
syn = "0.14.4"
quote = "0.6.3"
```

and the code:

```rust
// hello_macro_derive/src/lib.rs
extern crate proc_macro;

use crate::proc_macro::TokenStream;
use quote:quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
  let ast = syn::parse(input).unwrap();

  impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
  let name = &ast.ident;
  let gen = quote! {
    impl HelloMacro for #name {
      fn hello_macro() {
        println!("Hello, Macro! My name is {}", stringify!(#name));
      }
    }
  };
  gen.into()
}
```

### Attribute-like macros

*Attribute-like macros* allow to create new attributes, and can be applied to functions as well as traits and structs:

```rust
#[route(GET, "/")]
fn index() {
  // ...
}
```

the signature of the macro definition is:

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
  // ...
}
```

### Function-like macros

*Function-like macros* are used to produce some code at compile time, but at the level of the single statements, and they look like function calls:

```rust
let sql = sql!(SELECT * FROM posts WHERE id = 1);
```

a function-like macro take any number of `TokenStream` arguments, and return a `TokenStream`:

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
  // ...
}
```
