# Functional and Object-Oriented Programming

- [Higher-order functions](#higher-order-functions)
- [Iterators](#iterators)
- [Consumers and adapters](#consumers-and-adapters)
- [Generics](#generics)
- [Methods](#methods)
- [Traits](#traits)

## Higher-order functions

In Rust, functions are first-class elements, meaning that they can be treated exactly as any other value, namely assigned to variables, passed as function arguments, and returned from functions.

Simple functions can be defined without a name, and assigned to variables, like:
```rust
let triples = |n|{3 * n};
println!("{}", triples(3)); // prints "9"
```

Here the argument is defined between two `|` characters, followed by the function body. This would be an *anonymous function*, or *closure*. Closures have anonymous types that are automatically generated by the compiler for each different closure definition: this means that it's not possible to explicitly add a type annotation to the `triples` declaration.

Functions can also be passed to other functions:
```rust
fn again<F: Fn(i32) -> i32>(f: F, s: i32) -> i32 {
	f(f(s))
}
let mut strength = 50;
strength = again(triples, strength);
```

In the function definition we are required to specify the type of the function we are getting as first argument. The only way to do this is using a parameterized function, where the parameter defines the shape of the function, and is then used as the argument type.

We can still pass closures to functions taking other functions:
```rust
println!("{}", again(|n| { 3 * n }, 50));
```

For one-line function bodies, we can omit the curly braces:
```rust
println!("{}", again(|n| 3 * n, 50));
```

As usual, closures capture the enclosing context:
```rust
let x: i32 = 42;
let print_add = |s| {
	println!("x is {}", x);
	x + s
};
let res = print_add(strength);
```

where the context variable `x` is captured by the body of the closure, and still available when the function is executed.


## Iterators

Rust supports the so called *foreach* loops, which are loops iterating over iterators:
```rust
for v in "Hey, Joe".chars() {
	println!("{}", v);
}
```

where `chars()` returns an iterator over all the characters of the string slice. Another example is iterating over an array:
```rust
for v in [1, 2, 3].iter() {
	println!("{}", v);
}
```

where `[1, 2, 3].iter()` is equivalent to `&[1, 2, 3]`, since they both return an iterator over the array.

Iterators support the `next()` method, which is used to move the internal pointer to the next item of the sequence. This method returns the item encapsulated inside an `Option` structure, because when we move past the end of the sequence, there isn't any other value to get:
```rust
let mut a = [1, 2, 3].iter();
println!("{:?}", a.next()); // prints Some(1)
```

the original array must be mutable because we can modify the items through the iterator. Of course `for` loops are smart enough to automatically check if the next item is present, and unwrap it from the Option, or simply end the loop if there isn't any more value.

The `next()` method of an iterator actually returns a reference to the original value: this is important because it means that iterators don't copy the values of the original data structure, but just reference to them.

Imagine we weren't using iterators, but looping over the original array with an index instead:
```rust
let a = [1, 2, 3];
for i in 0..3 {
	println!("{}", a[i]);
}
```

here at each iteration the indexing operation `a[i]` would have to check if the given index is inside the array bounds, incurring in significant performance penalties. Using iterators, instead, the `next()` method is just returning what it finds in the contiguous memory location, without doing any check: if we are out of bounds, a `None` would be returned instead. This is one of the reasons why iterators are preferred over indexing for handling iterable data structures.

Iterators are lazy in nature, meaning that they generate values only when `next()` is called, instead of having all values stored in memory, and then reading them. Thus, we can easily handle big data structures without weighting on the memory:
```rust
let rng = 0..1_000_000;
```

here no value is actually allocated until we start using the range calling `next()`, or inside a `for` loop.


## Consumers and adapters

A *consumer* is a method that produces a values out of an iterator; an `adapter` is a method that produces a new iterator out of an iterator.

The `collect()` consumer iterates over all elements of an iterator, and stores them into a container, for example a vector:
```rust
let rng = 0..1000;
let rngvec: Vec<i32> = rng.collect();
```

of course this way we lose the memory benefit of iterators, because now we have all values allocated in memory at the same time. Since `collect()` is a parameterized function, we either have to tag the type of the container like we did in this case, or use the syntax `collect()::<Vec<i32>>`.

The `find()` consumer gets the first value of an iterator respecting the given condition:
```rust
let forty_two = rng.find(|n| *n >= 42);
```

this returns an Option, because the condition might be false for all values, in which case it would return `None`. Since, again, the iterator contains references to the original values, we need to first dereference each given value to compare it to `42`.

The `filter()` adapter produces a new iterator containing only the values that respect the given condition:
```rust
let rng_even = rng.filter(|n| *n % 2 == 0);
```

Of course, since an adapter returns a new iterator, we can apply another consumer or adapter to it in chain:
```rust
let even_values:Vec<i32> = rng.filter(|n| *n % 2 == 0).collect();
```

The `map()` adapter produces a new iterator whose values are obtained applying the given function to the original ones:
```rust
let rng_even_pow3:Vec<i32> = rng.filter(|n| *n % 2 == 0).map(|n| n * n * n).collect();
```

The `take()` adapter produces a new iterator containing only a subset of the original values, taken from the start:
```rust
let first_values = rng.take(5); // get only the first 5 elements
```

The `fold()` consumer (also called *reduce* in other languages) is used to calculate a resulting value applying a given function to all elements of the iterator, where at each invocation the result of the previous one is carried over:
```rust
let sum = 0..100.fold(0, |sum, n| sum + n);
```


## Generics

Generics are code structures where some types are not specified, so that they can work with types specified by the client. For example, `Vec` is generic because its definition doesn't specify what types the vector will contain: instead, the client will, for example declaring `Vec<i32>` or `Vec<Person>` (assuming that `Person` is some other data structure).

We can use generics when defining our own data structures:
```rust
struct Pair<T> {
	first: T,
	second: T
}
let magic_pair: Pair<u32> = Pair { first: 7, second: 42 };
```

here we don't want to specify what type the two elements of the pair will be, because we'd like the client to choose it, but we still want to enforce that both elements have the same type: this is done using the same `T` parameter on both elements. We could've also created a data structure with more than one parameterized type:
```rust
struct Couple<T, U> {
	first: T,
	second: U
}
let couple: Couple<u32, &str> = Couple { first: 4, second: "Hey, Joe" };
```

If a function takes a generic data structure, without selecting a specific type for the parameter, the function as well must be declared as generic:
```rust
fn second<T>(pair: Pair<T>) -> T {
	pair.second
}
```


## Methods

Rust allows to assign methods to structs with the `impl` construct:
```rust
struct Alien {
	health: u32,
	damage: u32
}

impl Alien {
	fn new(mut health: u32, damage: u32) -> Self {
		if h > 100 { h = 100; }
		Alien { health, damage }
	}
}

let mut berserk = Alien::new(150, 15);
```

By convention, the `new()` method is used to create a new instance of the specified struct. `new` is a static method, and as such it's not called on an instance, but on the type identifier itself. However, Rust doesn't enforce this convention, meaning that we are free of defining a constructor called `create()` for example, or anything else. `Self` is a shorthand to reference the name of the current struct.

Instance methods, on the other hand, need to be passed the invocation instance as first argument:
```rust
fn attack(&self) {
	println!("I attack! Your health lowers with {} damage points.". self.damage);
}
```

the invocation instance is by convention called `self`, and is of course passed as a reference.

If we wish to modify the current instance, we need to pass it as a mutable reference, and the instance must be declared as mutable:
```rust
fn attack(&mut self) {
	self.health -= 10;
}

let mut alien = Alien::new();
alien.attack();
```

notice, however, that in the `struct` definition we didn't declare `Alien`'s properties as mutable: this means that the mutability of an object properties is determined by the declaration of the instance `let mut alien` rather than `let alien`, instead of by the declaration of the properties. In addition to this, the declaration of the properties in the `struct` does not use `let`, so it would be impossible to put a `mut` there.

Because of how type inference work in Rust, there's no need to support method overloading. This means, then, that it's illegal to declare two methods with the same name.


## Traits

Rust doesn't have interfaces as programming constructs, like other languages like Java or C# do, but what is usually implemented with interfaces, Rust does with traits. Let's say that we want to define an interface `Monster`, featuring an `attack()` method: in Rust we would do:
```rust
trait Monster {
	fn attack(&self);
}
```

as we can see, traits contain only method signatures, but no implementations: exactly like traditional interfaces. If now we want the `Alien` struct to implement the `Monster` trait (interface), we can write:
```rust
impl Monster for Alien {
	fn attack(&self) {
		println!("I attack! Your health lowers with {} damage points.", self.damage);
	}
}
```

of course different structs can implement the same trait in different ways, provided that the signatures of the trait's methods are respected.

Unlike traditional interfaces, traits in Rust can define static methods, and have default implementations:
```rust
trait Monster {
	fn new(hlt: u32, dam: u32) -> Self;
	fn attack(&self);
	fn noise(&self) -> &'static str;
	fn attack_with_sound(&self) {
		println!("The monster attacks by making an awkward sound {}", self.noise());
	}
}
```

the `Self` keyword is used as a placeholder for the actual implementor's type. For instance, if this trait will be implemented in the `Alien` struct, in that case `Self` will be equivalent to `Alien`. Default implementations can be freely overriden by specific ones defined by each implementor. Default implementations of a trait may use `self` to refer to what will be the invocation object.

Traits can be implemented for all types, not only for custom structs:
```rust
trait Test {
	fn test(&self) {
		println!("Hey, Joe!");
	}
}

impl Test for String {}
impl Test for i32 {}

"".to_string().test(); // Prints "Hey, Joe!"
1.test(); // Prints "Hey, Joe!"
```

While working with generics, we might get to the point where we'd like some trait to be implemented by the parameterized type. For example:
```rust
extern crate num;
use num::traits::Float;

fn sqroot<T>(r: T) -> Result<T, String> {
	if r < 0.0 {
		return Err("Number cannot be negative!".to_string());
	}
	Ok(num::traits::Float::sqrt(r));
}
```

there are some problems here. First of all, `r` is of the generic, unknown type `T`: who knows if this type supports the `<` operator. Additionally, `num::traits::Float::sqrt()` cannot be applied to any type but only to those providing certain functionality. It turns out that both requirements are met by types implementing the `Float` trait, so we would like to specify that our type `T` must implement `Float`. To do this:
```rust
extern crate num;
use num::traits::Float;

fn sqroot<T: num::traits::Float>(r: T) -> Result<T, String> {
	// ...
}
```

This is called *trait constraint* or *trait bound*, and it's really logical if we consider that traits are interfaces, which are in turn types. Writing `T: num::traits::Float` can be read as "`T` must be of type `num::traits::Float`".

An important characteristic of Rust's traits is that when they're used to define polymorphic methods, different versions of those methods are created and assigned to each implementor at compile time. This means that the compiled code already knows where to find the implementations of each polymorphic method, and no lookup to the virtual table will be needed at runtime (unlike more traditional languages like Java).

Trait constraints can also be written with the following syntax:
```rust
fn sqroot<T>(r: T) -> Result<T, String> where T: num::traits::Float {
	// ...
}
```

which becomes more readable when there are more than one constraint on a type:
```rust
fn multc<T, U>(x: T, y: U) where T: Trait1, U: Trait1 + Trait2 {
	// ...
}
```

notice the `+` operator used to list the traits that must be implemented by `U`.

Like in other languages like Haskell, in Rust operators are just syntactic sugar for methods. For example, `+` is really just a call to the `add()` method in disguise. The `add()` method is in turn defined by the `Add` trait, meaning that we can overload the `+` operator for our types just implementing `Add`:
```rust
use std::ops::Add;

struct Test {
	value: String
}

impl Test {
	fn new(s: &str) -> Test {
		Test { value: s.to_string() }
	}

	fn test(&self) {
		println!("{}", self.value);
	}
}

impl Add for Test {
	type Output = Test;
	fn add(self, t: Test) -> Test {
		return Test::new(&format!("{} + {}", self.value, t.value));
	}
}

let t = Test::new("Hey");
let v = Test::new("Joe");
(t + v).test(); // Prints "Hey + Joe"
```

The `Add` trait requires first that we define an alias named `Output`, since in the trait definition it's left undefined, like in `type Option;`. Then, we need to define the `add()` function, that will be called when we use the `+` operator on objects of our `Test` type. Interestingly, this function takes the invocation object by value instead of by reference.
